package cmsc433.p3;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.Callable;

import cmsc433.p3.SkippingMazeSolver.SolutionFound;

/**
 * This file needs to hold your solver to be tested. 
 * You can alter the class to extend any class that extends MazeSolver.
 * It must have a constructor that takes in a Maze.
 * It must have a solve() method that returns the datatype List<Direction>
 *   which will either be a reference to a list of steps to take or will
 *   be null if the maze cannot be solved.
 */
/**
 * @author Zhehao Chen
 *
 */
public class StudentMTMazeSolver extends SkippingMazeSolver
{

	/**
	 * @param maze
	 */
	public StudentMTMazeSolver(Maze maze)
	{
		super(maze);
		// TODO Auto-generated constructor stub
	}

	/* (non-Javadoc)
	 * @see cmsc433.p3.MazeSolver#solve()
	 */
	@Override
	public List<Direction> solve()
	{
		// TODO Auto-generated method stub
		return null;
	}
	

	/**
	 * @author Zhehao Chen
	 *
	 * A class abstraction of an individual depth-first search task.
	 */
	/**
	 * @author Me
	 *
	 */
	private class DFSTask implements Callable<List<Direction>>
	{
		private Choice source;
		private Direction dir;
		
		
		/**
		 * @param source
		 * @param dir
		 */
		public DFSTask(Choice source, Direction dir)
		{
			source = this.source;
			dir = this.dir;
		}
		

		/** 
		 * Basically a shameless rip-off of STMazeSolverDFS's solve algorithm
		 * 
		 * @see java.util.concurrent.Callable#call()
		 * @see cmsc433.p3.STMazeSolverDFS#solve()
		 */
		@Override
		public List<Direction> call() throws Exception
		{
			LinkedList<Choice> choiceStack = new LinkedList<Choice>();
			Choice ch;

			try
			{
				choiceStack.push(firstChoice(maze.getStart()));
				while (!choiceStack.isEmpty())
				{
					ch = choiceStack.peek();
					if (ch.isDeadend())
					{
						// backtrack.
						choiceStack.pop();
						if (!choiceStack.isEmpty())
							choiceStack.peek().choices.pop();
						continue;
					}
					choiceStack.push(follow(ch.at, ch.choices.peek()));
				}
				// No solution found.
				return null;
			}
			catch (SolutionFound e)
			{
				Iterator<Choice> iter = choiceStack.iterator();
				LinkedList<Direction> solutionPath = new LinkedList<Direction>();
				while (iter.hasNext())
				{
					ch = iter.next();
					solutionPath.push(ch.choices.peek());
				}

				if (maze.display != null) maze.display.updateDisplay();
				return pathToFullPath(solutionPath);
			}
		}
		
	}
    
}
